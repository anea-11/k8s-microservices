apiVersion: apps/v1
kind: Deployment
metadata:
  name: xxx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: xxx
  template:
    metadata:
      labels:
        app: xxx
    spec:
      containers:
      - name: xxx
        image: xxx
        ports:
        - containerPort: xxx
        env:
        - name: ENV_VAR_1_NAME
          value: "ENV_VAR_1_VALUE"
        livenessProbe:
          periodSeconds: x
          exec: 
            command: ["xxx-exec-command", "xxx-args"]
        readinessProbe:
          periodSeconds: x
          exec: 
            command: ["xxx-exec-command", "xxx-args"]
        resources:
          requests:
            cpu: 100m   
            memory: 64Mi
          limits:
            cpu: 200m
            memory: 128Mi

---
apiVersion: v1
kind: Service
metadata:
  name: xxx
spec:
  selector:
    app: xxx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 8080
  type: ClusterIP

---
# livenessProbe: k8S is automatically checking if pod is alive and well; if something is wrong with the pod, it will restart it (autohealing). However, k8S 
# does not know on its own if the app that's running inside of a container that's running in that pod is ok. For example, you can have a pod that's not crashing
# but the app inside of it is stuck because of some bug. Liveness probe is used to check if the app is healthy. It is configured on container level. This probe
# can be a tiny program or a script that's running inside of the container and periodically checks if the app is healthy (by pinging its endpoint). Sometimes
# developers will provide this app, and other times it's the devops engineer that should implement it. Another mechanism that's used for this probe is tcpSocket.
# In livenessProbe definition, you specify a port on which k8S will try to open a socket. If this socket opens successfully, the app is considered to be alive.
# ANother mechanism is httpGet. The app itself can expose an endpoint that the liveness probe will hit to check for the health status.
# tcpSocket example: redis; health-check app example: all the other microservices; httpGet example: not commited, search online

# readinessProbe: since k8S is aware of the pod state, but not aware of the state of the app that's running inside of it, a mechanism that will allow k8S to 
# figure out that the app started successfully is needed. Readiness probe is used for this. It is very similar to liveness probe, but it's used during the app
# startup. Some apps take a long time to start (few mins), so if k8S does not know that the app isn't up and running yet, it will start forwarding requests to
# it and we will get errors. Readiness probes tells k8S once the startup process is done and the app is up.

# resources: we should tell k8S what cpu and memory resources our apps need; we get this info from developers; 
# resources:requests: this defines the cpu and memory that our app needs to run
# resources:limits: this defines the limits for our app; if the app uses more than what's specified here, that is not ok and it's probably a bug, so k8s should
# kill its pod; 
# cpu is expressed in millicores - millicores indicate the relative share of the collective CPU pool available on a node; this abstracts away the actual
# underlying hardware - basically whatever number of physical CPUs/cores you have on the node, it is treated as a collective pool of CPU, and millicores are
# relative to this collective pool
# memory is expressed in Mi (mebibytes): 1Ki(kibibyte) = 2^10B; 1Mi(mebybyte) = 2^10 * 2^10 B = 2^20 B